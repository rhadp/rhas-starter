kind: Task
apiVersion: tekton.dev/v1beta1
metadata:
  name: aib-build
spec:
  params:
    - name: JOB_ID
      description: "the reference used to track the job and access its assets"
      type: string
      default: ""
    - name: MANIFEST_FILE
      description: "manifest file to build"
      type: string
      default: "manifests/simple.aib.yml"
    - name: DISTRO
      type: string
      default: "autosd10-sig"
    - name: ARCH
      type: string
      default: "aarch64"
    - name: TARGET
      type: string
      default: "qemu"
    - name: EXPORT_FORMAT
      type: string
      default: "qcow2"
    - name: AIB_IMAGE
      type: string
      default: "quay.io/centos-sig-automotive/automotive-image-builder:latest"

  results:
    - description: Name of the image file
      name: IMAGE_NAME
      type: string
    - description: Full path of the image file
      name: IMAGE_PATH
      type: string

  steps:
    - name: aib-build
      image: $(params.AIB_IMAGE)

      resources:
        requests:
          memory: "4Gi"
          cpu: "500m"
        limits:
          memory: "8Gi"
          cpu: "2"

      script: |
        #!/usr/bin/env bash
        
        set -euo pipefail

        # === Container Storage Configuration ===
        echo "Configuring container storage..."

        if command -v fuse-overlayfs &> /dev/null; then
            echo "fuse-overlayfs found at: $(which fuse-overlayfs)"
            STORAGE_DRIVER="overlay"
        else
            echo "WARNING: fuse-overlayfs not found, falling back to vfs driver"
            STORAGE_DRIVER="vfs"
        fi

        CONTAINER_STORAGE_PATH="$(workspaces.source.path)/.container-storage"
        BUILD_PATH="$(workspaces.source.path)/.build-cache"

        mkdir -p "$CONTAINER_STORAGE_PATH"
        mkdir -p "$BUILD_PATH"
        mkdir -p /run/containers/storage
        mkdir -p /etc/containers

        cat > /etc/containers/storage.conf <<EOF
        [storage]
          driver = "$STORAGE_DRIVER"
          runroot = "/run/containers/storage"
          graphroot = "$CONTAINER_STORAGE_PATH"

        [storage.options.overlay]
          mount_program = "/usr/bin/fuse-overlayfs"
          mountopt = "nodev,metacopy=on"
        EOF

        # Symlink for tools that use hardcoded paths
        rm -rf /var/lib/containers/storage
        mkdir -p /var/lib/containers
        ln -sf "$CONTAINER_STORAGE_PATH" /var/lib/containers/storage

        echo "Container storage configured with driver: $STORAGE_DRIVER"

        # === OSBuild Configuration ===
        OSBUILD_PATH="/usr/bin/osbuild"
        RUN_TMP_PATH="/run/osbuild/"

        mkdir -p "$RUN_TMP_PATH"

        if ! mountpoint -q "$OSBUILD_PATH"; then
            ROOT_TYPE="system_u:object_r:root_t:s0"
            chcon "$ROOT_TYPE" "$BUILD_PATH" || true

            INSTALL_TYPE="system_u:object_r:install_exec_t:s0"
            if ! mountpoint -q "$RUN_TMP_PATH"; then
                mount -t tmpfs tmpfs "$RUN_TMP_PATH"
            fi

            DEST_PATH="$RUN_TMP_PATH/osbuild"
            cp -p "$OSBUILD_PATH" "$DEST_PATH"
            chcon "$INSTALL_TYPE" "$DEST_PATH" || true
            mount --bind "$DEST_PATH" "$OSBUILD_PATH"
        fi

        # === Docker Credentials ===
        if [[ "$(workspaces.dockerconfig.bound)" == "true" ]]; then
            if test -f "$(workspaces.dockerconfig.path)/config.json"; then
                export DOCKER_CONFIG="$(workspaces.dockerconfig.path)"
            elif test -f "$(workspaces.dockerconfig.path)/.dockerconfigjson"; then
                mkdir -p "$HOME/.docker"
                cp "$(workspaces.dockerconfig.path)/.dockerconfigjson" "$HOME/.docker/config.json"
                export DOCKER_CONFIG="$HOME/.docker"
            else
                echo "neither 'config.json' nor '.dockerconfigjson' found at workspace root"
                exit 1
            fi
        fi

        # === Build Image ===
        cd $(workspaces.source.path)

        MANIFEST_FILE=$(workspaces.source.path)/$(params.MANIFEST_FILE)
        CANONICAL_NAME=$(params.DISTRO)-$(params.TARGET)
        EXPORT_FILE_NAME=${CANONICAL_NAME}.$(params.EXPORT_FORMAT)
        OUTPUT_DIR=$(workspaces.source.path)/output

        mkdir -p "$OUTPUT_DIR"

        # Single command builds container image AND disk image
        # AIB automatically handles build-builder internally when needed
        automotive-image-builder build \
            --distro $(params.DISTRO) \
            --target $(params.TARGET) \
            --format $(params.EXPORT_FORMAT) \
            --arch=$(params.ARCH) \
            --build-dir="$BUILD_PATH" \
            --osbuild-manifest="$OUTPUT_DIR/build.json" \
            --verbose \
            "$MANIFEST_FILE" \
            - \
            "$OUTPUT_DIR/${EXPORT_FILE_NAME}"

        # "localhost/${CANONICAL_NAME}"
        
        # === Copy Artifacts ===
        mkdir -p $(workspaces.source.path)/binaries

        # Find and copy the disk image
        if [ -f "$OUTPUT_DIR/${EXPORT_FILE_NAME}" ]; then
            cp -v "$OUTPUT_DIR/${EXPORT_FILE_NAME}" $(workspaces.source.path)/binaries/
        else
            # Search for generated image if not at expected location
            GENERATED_IMAGE=$(find "$OUTPUT_DIR" -type f \( -name "*.qcow2" -o -name "*.raw" \) | head -n1)
            if [ -n "$GENERATED_IMAGE" ] && [ -f "$GENERATED_IMAGE" ]; then
                cp -v "$GENERATED_IMAGE" "$(workspaces.source.path)/binaries/${EXPORT_FILE_NAME}"
            else
                echo "ERROR: Could not find generated disk image"
                ls -laR "$OUTPUT_DIR/"
                exit 1
            fi
        fi

        cp -v "$OUTPUT_DIR/build.json" $(workspaces.source.path)/binaries/build.json || true

         # write results
        echo -n "$EXPORT_FILE_NAME" > $(results.IMAGE_NAME.path)
        echo -n "$(workspaces.source.path)/binaries/$EXPORT_FILE_NAME" > $(results.IMAGE_PATH.path)

        echo "Build complete: $EXPORT_FILE_NAME"

      securityContext:
        capabilities: {}
        privileged: true
        seLinuxOptions:
          type: unconfined_t

      volumeMounts:
        - mountPath: /run/osbuild
          name: run-dir
        - mountPath: /dev
          name: dev
        - mountPath: /run/containers
          name: container-run

  volumes:
    - emptyDir: {}
      name: run-dir
    - hostPath:
        path: /dev
      name: dev
    - emptyDir: {}
      name: container-run

  workspaces:
    - name: source
    - name: dockerconfig
      description: Includes a docker `config.json`
      optional: true
